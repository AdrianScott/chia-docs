---
id: prefarm_custody_english
title: Prefarm Custody (English Description)
sidebar_label: Prefarm Custody (English Description)
sidebar_position: 7
---

# Prefarm Custody (English Description)
Chia Network Inc will choose a time at which to move most of the prefarm into two new cold wallets. The custodial arrangements of both wallets will be identical. This document will describe these arrangements in plain English.

## Distribution Amounts
* From the prefarm's original size of 21 million XCH,
  * A yet-to-be-determined amount XCH will be not be subject to the arrangement laid out in this document
  * Of the remaining XCH, some will be custodied by Chia Network Inc (CNI), and some by CNI's Swiss sister company. The amount custodied in each location may or may not be equal

## Withdrawal Rate
The withdrawal rate is the custodial wallet's principal rule. This rule supersedes all other rules of the wallet. No individual or group may modify this rule. Ever.

Here's how it works:
* CNI's and the Swiss company's portion of the prefarm will each be moved to their respective cold custodial wallets. Each wallet will contain a pre-configured Unix timestamp called `start_date`, which will be purposely set to a future time, some days or weeks after the wallet's creation. When `start_date` is reached, the entire amount contained in the wallets will be frozen
* From `start_date` forward, a constant number of mojos become available to be withdrawn with each passing second. This number must be decided in advance of the wallet's creation
* The amount of available mojos increases linearly, until the entire prefarm has become available. The plan is to configure this rate such that this process will take ten years.
* The number of mojos considered _available_ is based on the time that a withdrawal is _initiated_, as explained later in this document
* Even after certain mojos have become available, they will not automatically be withdrawn. They will still need to follow the rest of the rules laid out in this document
* The mojos that are not yet available are frozen. There is no override function

The following formula will calculate how many mojos have been made available to be withdrawn from each wallet:

`num_mojos` = `num_seconds` * `mojo_const`

Where:
  * `num_mojos` is the number of mojos available to be withdrawn
  * `num_seconds` is the number of seconds after `start_date`
  * `mojo_const` will be decided before creating the custodial wallets

-----

## Singleton Structure

Both of the prefarm's custodial wallets use a singleton with five main features:
1. **Withdrawal rate** -- as discussed in the previous section, funds are made available to be withdrawn at a constant rate of some number of mojos per second

2. **Multisig** -- required to perform actions on the singleton, where:
  * The total number of keys in the multisig is initially set to 5, which will be referred to as `N` for the rest of this document. `N` can be changed with a rekey (explained later)
  * Initially, 3 keys will be required to perform withdrawals and standard rekeys (explained later). This number will be referred to as `M` for the rest of this document. `M` can be thought of as the _security level_ for the wallet. This variable can be modified to be as large as `N`. For the prefarm, it can be as small as 1, though other custodial wallets could set the minimum to a larger number

3. **Merkle root** -- Chialisp puzzles representing the `N` keys are stored in a Merkle tree, where:
  * Puzzles representing every combination of keys, from 1 to `M`, are stored. If the keys are A, B, C, D and E, and `M` is 3, then the combinations to be stored are ABC, ABD, ABE, ACD, ACE, ADE, BCD, BCE, BDE, CDE, AB, AC, AD, AE, BC, BD, BE, CD, CE, DE, A, B, C, D and E
  * The Merkle root of this tree is curried (pre-committed) into the singleton
  * The Merkle root of a tree containing puzzles of all possible combinations for `M` + 1 is also curried into the singleton. This is required in case of a lock level increase (explained later). This root is recursive, in that it contains puzzles that have combinations for `M` + 2 committed to them, leading up to the level where `M` = `N`.
  * In order to spend a coin from this wallet, a node in the Merkle tree, along with a Proof of Inclusion, are required to be passed into the singleton's solution. The Proof of Inclusion must prove the node's existence in the current Merkle root in order for the spend to succeed
  * The Merkle tree is stored in a private location. However, even if it is stolen, the thief will not gain access to the wallet because `M` digital signatures are still required (see below for a more detailed analysis)
  * The Merkle tree is generated deterministically, based on the `N` pubkeys. If the Merkle tree is lost, it can be regenerated by using the `N` pubkeys
  
4. **Withdrawal Timelock** -- This is a timelock on initiating a withdrawal, referred to as `W` for the rest of this document. The value of `W` is set upon the wallet's creation and can never be changed. It will be explained in detail below. (Note that this is completely separate from the withdrawal rate discussed in 1 above.)

5. **Rekey Timelock** -- This is a timelock on initiating a rekey, referred to as `T` for the rest of this document. The value of `T` is set upon the wallet's creation and can never be changed. It will be explained in detail below. (Note that this is completely separate from the withdrawal rate discussed in 1 above.)

-----

## Allowed Actions
Three separate actions are allowed on the wallet's singleton: withdrawals, rekeys (normal and slow) and lock level increases. Each of these actions will be discussed in detail in this section.

### Withdrawal
This action removes money from the wallet

  > Note that the rate limit, as discussed above, must always be followed for all withdrawals

* In order for a withdrawal to be initiated, exactly `M` of `N` signatures are required

Two timelocks must be completed to perform a withdrawal, a _withdrawal timelock_ and a _drop coin timelock_.

#### Withdrawal Timelock
This is a timelock before the singleton can begin the withdrawal process. This timelock has the following rules:
  * `W` days must have elapsed since any actions (other than a lock level increase, explained below) have been performed on the singleton
  * This is a _de facto_ gateway; the `W`-day condition either has, or has not been met
  * The `W`-day length cannot be modified

If the withdrawal timelock condition has not been met, then a withdrawal may not be initiated. If it has been met, then a withdrawal may be initiated. The next phase is the _drop coin timelock_.

#### Drop Coin Timelock
Upon entering this phase, the singleton creates a _drop coin_ of the amount of XCH to be withdrawn. A drop coin has several rules:
  * It has a curried XCH payout address, to where the money is flagged to be withdrawn
  * It has a hard-coded timelock, referred to as `D` for the rest of this document
  * Because the drop coin cannot be spent for `D` days, it functions as an escrow
  * The drop coin contains the same Merkle root that was used in the singleton
  * At any point before the drop coin has been spent, _claw back_ is allowed. Claw back has the following features:
    * It cancels the withdrawal and returns the money to the custodial wallet's singleton. It uses `p2_singleton` to accomplish this, so there is further action needed for the funds to be absorbed into the singleton
    * It requires `M` of `N` signatures
    * The `M` signatures don't have to be the same as the ones that initiated the withdrawal. In other words, different people could claw back the withdrawal than those who initiated it
  * After `D` days, if a claw back has not been performed, _claw forward_ becomes possible. Claw forward has the following features:
    * It completes the withdrawal to a pre-specified XCH address
    * **Anyone** is allowed to perform a claw forward
    * Even though a claw forward can be performed by anyone, it is secure because the withdrawal address is not changeable

### Rekey
This action changes the keys associated with the wallet's singleton.

`K` keys are required for a rekey, where:
  * For a _standard_ rekey, `K = M`
  * For a _slow_ rekey, `1 <= K < M`. (A slow rekey could be performed with just one key.)

Either type of rekey can also modify `M` and/or `N` if desired. We'll discuss the circumstances where each type of rekey will be performed later in this section.

Two timelocks must be completed to perform a rekey, an _initiation timelock_ and a _drop coin timelock_.

#### Initiation Timelock
This is a timelock before the singleton can begin the rekey process. The length of this timelock is the number of days that must have elapsed since any actions (other than a lock level increase, explained below) have been performed on the singleton. This is a _de facto_ gateway; the timelock condition either has, or has not been met.

Unlike the withdrawal timelock, the length of this timelock is not a constant. In order to calculate this timelock's length, several factors must be considered:

* Start by calculating `X`, where `X = M - K + 1`
  * If `X` is `1`, then it's a standard rekey (`K = M`)
  * If `X > 1`, then it's a slow rekey. `X` represents the gap between the `K` keys being used with this rekey and `M + 1` (the number of keys required for a lock level increase, as explained below)
* For a standard rekey, the initiation timelock duration is `T`. As discussed above, `T` is stored in the singleton and can never be changed
* For a slow rekey, a time penalty `P` days is automatically applied. The value of `P` also can never be changed
* The duration of the initiation timelock of a slow rekey is `P + T*X` days. In other words, a penalty of `T` days gets added for each key less than `M`

The following table illustrates a few examples of initiation timelock lengths, for various values of `M` and `K`. For this table, `T` is set to 15 days and `P` is set to 45 days. The table assumes that `N` (5) and the minimum `K` (1) have not been modified from their default values:

`M` | `K` | Days | Comment |
:--:|:---:|:----:|:------- |
3   | 3   | 15   | Standard rekey, no penalty |
3   | 2   | 75   | Slow rekey, `P` day penalty + 2 * standard `T` days |
3   | 1   | 90   | Slow rekey, `P` day penalty + 3 * `T` days |
1   | 1   | 15   | This is a case where, after a prior rekey, `M` was reduced to 1. There is no penalty, even with a single key |
5   | 3   | 90   | In this case, a lock level increase has been performed, so 5 of 5 keys are required to avoid a penalty|
5   | 1   | 120  | This is the longest possible initiation timelock duration when `N` is 5 and the minimum `K` is 1. In this case, `M` has been increased to 5, and 1 key is being used for the rekey |
... |...  | ...  | Other combinations for `M` and `K` are possible, but not shown here |

If the singleton has been modified within the timelock's required number of days, then the initiation timelock condition has not been met, and a rekey may not be initiated. If the initiation timelock condition has been met, then a withdrawal may be initiated. The next phase is the _drop coin timelock_. `K` is carried over to this phase.

#### Drop Coin Timelock
Upon entering this phase, the singleton creates a _drop coin_ with 0 value. This drop coin has several rules:
* It has a hard-coded timelock, hereafter referred to as `D'`
* The same Merkle root that was used in the singleton is curried into the drop coin
* A new Merkle root is also curried into the drop coin. After the rekey has completed, this will become the Merkle root of the puzzles representing the new keys. Therefore, the new keys, along with the new Merkle tree, must have been generated before the drop coin was created
* At any point before the drop coin has been spent, _claw back_ is allowed. Claw back has the following features:
  * It cancels the rekey; the custodial wallet's singleton is left unmodified
  * It requires `K` signatures (the number of keys that initiated the rekey)
  * The `K` signatures don't have to be the same as the ones that initiated the rekey. In other words, different people could claw back the rekey than those who initiated it
* After `D'` days, if a claw back has not been performed, _completion_ becomes possible. Completion has the following features:
  * It spends the drop coin, which creates a puzzle announcement for the singleton to use
  * It also spends the singleton, which asserts the puzzle announcement from the drop coin, and recreates itself with the new Merkle root curried in
  * `M` and/or `N` could be set to different numbers in the new singleton
  * **Anyone** is allowed to perform the completion
  * Even though the completion can be performed by anyone, it is secure because the new Merkle root has already been committed to

Note that because `D'` is hard-coded, a second rekey can't overtake a rekey that has already been initiated. If rekey A is in progress and someone attempts rekey B, then A will succeed and B will fail.

### Lock Level Increase
This action increases the wallet's security (`M`) by 1. It has the following features:
* `M + 1` keys are required to perform a lock level increase
* The effect is immediate -- there is no timelock
* The keys themselves don't change
* This action is secure because the new Merkle root has been pre-committed
* In running this action, the singleton is spent and a new copy is created, with a new Merkle root curried in. This new root is taken from a Merkle tree containing every possible combination of keys from the new `M` down to 1
* This action automatically invalidates all outstanding rekey attempts because the Merkle root has changed in the new copy of the singleton
* This action does _not_ invalidate outstanding withdrawal attempts

### When are Normal Rekey, Slow Rekey and Lock Level Increase needed?
Normally, each of the keys will be in a Secure state. This means that the original owner still possesses the key, and no adversaries have gained access to it.

Keys have three other possible states:
* Sniffed -- An adversary has gained access to the key. The owner still has a copy 
* Stolen -- An adversary has gained access to the key. The owner no longer has a copy
* Lost -- The owner has lost the key. Nobody else has gained access to it

If a sufficient number of keys are sniffed, stolen or lost, there are three potential catastrophic consequences:
* Deadlocked -- The owners and adversaries each attempt to rekey and claw back those attempts. Neither side obtains the funds until the other side gives up
* Drained -- Attackers are able to steal the funds
* Bricked -- Nobody is able to access the funds

Any time one or more keys have been sniffed, stolen or lost, a rekey will be performed if possible. 

Additionally, the Merkle tree has the same four possible states as the keys (secure, sniffed, stolen, lost). The Merkle tree is needed to perform withdrawals, rekeys and lock level increases. This tree will be kept private. It can be regenerated with all `N` keys. This implies that different mitigation techniques will need to be undertaken, depending on the state of the tree.

The following tables list the action/consequence for each state of the Merkle tree, given the current value of `M` and the state of the keys:

#### Merkle Tree: Secure
| `M` | Keys Sniffed | Keys Stolen | Keys Lost |
|:----|:--------|:-------|:-----|
| 3   | 1-2: normal rekey <br/> 3: lock level increase to 4, normal rekey <br/> 4: lock level increase to 5, normal rekey <br/> 5: deadlocked | 1-2: normal rekey <br/> 3-4: slow rekey <br/> 5: drained | 1-2: normal rekey <br/> 3-4: slow rekey <br/> 5: bricked |
| 4   | 1-3: normal rekey <br/> 4: lock level increase to 5, normal rekey <br/> 5: deadlocked  | 1: normal rekey <br/> 2-4: slow rekey <br/> 5: drained | 1: normal rekey <br/> 2-4: slow rekey <br/> 5: bricked |
| 5   | 1-4: normal rekey <br/> 5: deadlocked | 1-4: slow rekey <br/> 5: drained | 1-4: slow rekey <br/> 5: bricked |

<br/>

#### Merkle Tree: Sniffed
| `M` | Keys Sniffed | Keys Stolen | Keys Lost |
|:----|:--------|:-------|:-----|
| 3   | 0-2: normal rekey <br/> 3: lock level increase to 4, normal rekey <br/> 4: lock level increase to 5, normal rekey <br/> 5: deadlocked | 0-2: normal rekey <br/> 3-5: drained | 0-2: normal rekey <br/> 3-4: slow rekey <br/> 5: bricked |
| 4   | 0-3: normal rekey <br/> 4: lock level increase to 5, normal rekey <br/> 5: deadlocked  | 0-1: normal rekey <br/> 2: slow rekey <br/> 3-5: drained | 0-1: normal rekey <br/> 2-4: slow rekey <br/> 5: bricked |
| 5   | 0-4: normal rekey <br/> 5: deadlocked | 0: normal rekey <br/> 1-2: slow rekey <br/> 3-5: drained | 0: normal rekey <br/> 1-4: slow rekey <br/> 5: bricked |

<br/>

#### Merkle Tree: Stolen
| `M` | Keys Sniffed | Keys Stolen | Keys Lost |
|:----|:--------|:-------|:-----|
| 3   | 0-2: normal rekey <br/> 3: lock level increase to 4, normal rekey <br/> 4: lock level increase to 5, normal rekey <br/> 5: deadlocked | 0: normal rekey <br/> 1-5: drained | 0: normal rekey <br/> 1-5: bricked |
| 4   | 0-3: normal rekey <br/> 4: lock level increase to 5, normal rekey <br/> 5: deadlocked  | 0: normal rekey <br/> 1-5: drained | 0: normal rekey <br/> 1-5: bricked |
| 5   | 0-4: normal rekey <br/> 5: deadlocked | 0: normal rekey <br/> 1-5: drained | 0: normal rekey <br/> 1-5: bricked |

<br/>

#### Merkle Tree: Lost
| `M` | Keys Sniffed | Keys Stolen | Keys Lost |
|:----|:--------|:-------|:-----|
| 3   | 0-2: normal rekey <br/> 3: lock level increase to 4, normal rekey <br/> 4: lock level increase to 5, normal rekey <br/> 5: deadlocked | 0: normal rekey <br/> 1-4: bricked <br/> 5: drained | 0: normal rekey <br/> 1-5: bricked |
| 4   | 0-3: normal rekey <br/> 4: lock level increase to 5, normal rekey <br/> 5: deadlocked  | 0: normal rekey <br/> 1-4: bricked <br/> 5: drained | 0: normal rekey <br/> 1-5: bricked |
| 5   | 0-4: normal rekey <br/> 5: deadlocked | 0: normal rekey <br/> 1-4: bricked <br/> 5: drained | 0: normal rekey <br/> 1-5: bricked |

Note that the worst outcomes tend to happen when the Merkle tree is either lost or stolen. The tree should never fall into either of these states because multiple backups will be securely stored. If the tree is merely sniffed, it won't result in catastrophe unless all of the private keys are also sniffed or lost, or if three or more keys are stolen. Therefore, while it is preferable to keep the tree secure, avoiding it being lost or stolen is far more important than avoiding it being sniffed.

Also note that regardless of the state of the Merkle tree, if an attacker sniffs 4 of the keys, the prefarm will still be safe, pending a rekey. Even if the attacker sniffs all 5 keys, he or she still will not gain control of the prefarm. Instead, a deadlock will ensue.

-----

## Source Code

The source code for the custody solution is in the [internal-custody GitHub repository](https://github.com/Chia-Network/internal-custody "Chia internal custody solution").

There are two configuration files, one that can be made public (for observers) and one that should be kept private.

### Public Configuration
An observer can track the prefarm's configuration information from [prefarm_info.py](https://github.com/Chia-Network/internal-custody/blob/main/cic/drivers/prefarm_info.py#L8-L18 "public configuration information"), which contains the following variables:
* `launcher_id`: `bytes32` -- This is pre-set; the user cannot change it
* `start_date`: `uint64` -- On what date are withdrawals allowed to start?
* `starting_amount`: `uint64` -- How many mojos will the cold wallet start with?
* `mojos_per_second`: `uint64` -- How many mojos per second will be made available to be withdrawn?
* `puzzle_root`: `bytes32` -- This is pre-set; the user cannot change it
* `withdrawal_timelock`: `uint64` -- How long must the singleton remain unspent in order to initiate a withdrawal?
* `payment_clawback_period`: `uint64` -- How long do signers have to claw back a payment?
* `rekey_clawback_period`: `uint64` -- How long to claw back a rekey?
* `slow_rekey_timelock`: `uint64` -- What is the penalty P that is applied to the singleton timelock when initiating a slow rekey?
* `rekey_increments`: `uint64` -- What is the timelock increment for using fewer keys?

### Private Configuration
The necessary information to spend the prefarm is located in [puzzle_root_construction.py](https://github.com/Chia-Network/internal-custody/blob/627b4155becfadbcd0a565412019297ae2db8b6b/cic/drivers/puzzle_root_construction.py#L24-L32 "private configuration information"). This information is considered private. However, if an attacker obtained this information, it would still be insufficient to spend the prefarm because valid signatures would be required. However, the Merkle tree would be considered sniffed, so a rekey would be required.

This code contains the following variables:
* `prefarm_info`: `PrefarmInfo` -- The info from the public file
* `pubkey_list`: `List[G1Element]` -- What are the set of pubkeys?
* `required_pubkeys`: `uint32` -- How many keys are required for payments and standard rekeys (`M` initially is 3 for the prefarm)?
* `maximum_pubkeys`: `uint32` -- What is the maximum lock level (`N` is 5 for the prefarm)?
* `minimum_pubkeys`: `uint32` -- What is the minimum number of keys required for a slow rekey (1 for the prefarm, but could be higher if so desired).
* `next_root`: `Optional[bytes32]` -- What will the root key be in the event of a rekey?
* `filter_proofs`: `ProofType`
* `leaf_proofs`: `ProofType`