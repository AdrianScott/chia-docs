"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[6988],{3905:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return f}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),h=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},c=function(e){var t=h(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=h(r),f=a,d=u["".concat(l,".").concat(f)]||u[f]||p[f]||o;return r?n.createElement(d,s(s({ref:t},c),{},{components:r})):n.createElement(d,s({ref:t},c))}));function f(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var h=2;h<o;h++)s[h]=r[h];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}u.displayName="MDXCreateElement"},6600:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return h},toc:function(){return c},default:function(){return u}});var n=r(7462),a=r(3366),o=(r(7294),r(3905)),s=["components"],i={sidebar_position:2},l="10.2 Harvester Protocol",h={unversionedId:"10protocol/harvester_protocol",id:"10protocol/harvester_protocol",isDocsHomePage:!1,title:"10.2 Harvester Protocol",description:"The harvester protocol defines the messages sent between a farmer service and a harvester service. These tend to",source:"@site/docs/10protocol/harvester_protocol.md",sourceDirName:"10protocol",slug:"/10protocol/harvester_protocol",permalink:"/docs/10protocol/harvester_protocol",editUrl:"https://github.com/Chia-Network/chia-docs/docs/10protocol/harvester_protocol.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"10.1 Chia Protocol",permalink:"/docs/10protocol/protocol"},next:{title:"10.3 Full Node Protocol",permalink:"/docs/10protocol/full_node_protocol"}},c=[{value:"harvester_handshake",id:"harvester_handshake",children:[]},{value:"new_signage_point_harvester",id:"new_signage_point_harvester",children:[]}],p={toc:c};function u(e){var t=e.components,r=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"102-harvester-protocol"},"10.2 Harvester Protocol"),(0,o.kt)("p",null,"The harvester protocol defines the messages sent between a farmer service and a harvester service. These tend to\nbe one the same machine for small farmers, but for medium or large farmers they can be in multiple machines."),(0,o.kt)("h2",{id:"harvester_handshake"},"harvester_handshake"),(0,o.kt)("p",null,"The handshake between farmer and harvester.\nA farmer sends this message to harvesters, to initialize them and tell them which\npool public keys and farmer public keys are acceptable to use."),(0,o.kt)("p",null,"A farmer can be connected to multiple harvesters, but a harvester should only have one farmer connection.\nThe harvester can start using plots which have these keys associated with them."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"class HarvesterHandshake(Streamable):\n    farmer_public_keys: List[G1Element]\n    pool_public_keys: List[G1Element]\n")),(0,o.kt)("h2",{id:"new_signage_point_harvester"},"new_signage_point_harvester"),(0,o.kt)("p",null,"PK"),(0,o.kt)("p",null,"This message notifies the harvester of a new challenge.\nThe harvester looks up the challenge in each of the plots, and computes the quality.\nThis requires around 7 disk seeks for each quality.\nEach plot is expected to have one proof of space on average, so for 50 plots, a harvester would have around 50 qualities."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"class NewSignagePointHarvester:\n    challenge_hash: bytes32\n    difficulty: uint64\n    sub_slot_iters: uint64\n    signage_point_index: uint8\n    sp_hash: bytes32\n    pool_difficulties: List[PoolDifficulty]\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Python"},"class ChallengeResponse:\n    challenge_hash: bytes32\n    quality_string: bytes32\n    plot_size: uint8\n")),(0,o.kt)("p",null,"The harvester sends a response to the farmer, with ",(0,o.kt)("inlineCode",{parentName:"p"},"ChallengeResponse")," for each of the qualities found."),(0,o.kt)("p",null,"After receiving a ",(0,o.kt)("inlineCode",{parentName:"p"},"ChallengeResponse"),", farmers can use the quality to compute the expected time required to finalize a block with this proof of space.\nIf this time is lower than a threshold (a small constant times expected block size), which means the proof of space is very good, the farmer can request the entire proof of space from the harvester through ",(0,o.kt)("inlineCode",{parentName:"p"},"RequestProofOfSpace"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Python"},"class RequestProofOfSpace:\n    quality_string: bytes32\n")),(0,o.kt)("p",null,"The farmer requests the entire proof of space from the harvester, which will require more disk seeks (around 50).\nThis is done only for proofs with high quality."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Python"},"class RespondProofOfSpace:\n    quality_string: bytes32\n    proof: ProofOfSpace\n")),(0,o.kt)("p",null,"The harvester responds with the requested proof of space.\nThe farmer can now choose to request a partial for this proof (to send to a pool), or if the proof is extremely good, to make a block.\nIn order to make a block the farmer must request a block header from the full node using ",(0,o.kt)("inlineCode",{parentName:"p"},"RequestHeader")," (which is in the farmer protocol), and then get a signature from the harvester using ",(0,o.kt)("inlineCode",{parentName:"p"},"RequestHeaderSignature"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Python"},"class RequestHeaderSignature:\n    quality_string: bytes32\n    header_hash: bytes32\n")),(0,o.kt)("p",null,"The farmer requests a header signature for a header with the given hash.\nThe harvester signs the header using the locally stored private key.\nThis allows farmers to store their private keys in a more distributed way, with each harvester machine storing keys along with the plots."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Python"},"class RespondHeaderSignature:\n    quality_string: bytes32\n    header_hash_signature: PrependSignature\n")),(0,o.kt)("p",null,"The harvester responds with a BLS prepend signature on the header hash."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Python"},"class RequestPartialProof:\n    quality_string: bytes32\n    farmer_target_hash: bytes32\n")),(0,o.kt)("p",null,"The farmer requests a partial proof to be used for claiming pool rewards.\nThese are sent much more often than ",(0,o.kt)("inlineCode",{parentName:"p"},"RequestHeaderSignature"),", since pool partials happen more often than good blocks.\nThe harvester signs that farmer target hash (target of funds) with the plot private key."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-Python"},"class RespondPartialProof:\n    quality_string: bytes32\n    farmer_target_signature: PrependSignature\n")),(0,o.kt)("p",null,"The harvester responds with the signature, which the farmer can then send to the pool to claim funds."))}u.isMDXComponent=!0}}]);