"use strict";(self.webpackChunkchia_docs=self.webpackChunkchia_docs||[]).push([[5489],{3905:(e,t,o)=>{o.d(t,{Zo:()=>p,kt:()=>u});var n=o(7294);function a(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function r(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?r(Object(o),!0).forEach((function(t){a(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,n,a=function(e,t){if(null==e)return{};var o,n,a={},r=Object.keys(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||(a[o]=e[o]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)o=r[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(a[o]=e[o])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var o=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(o),u=a,h=d["".concat(s,".").concat(u)]||d[u]||f[u]||r;return o?n.createElement(h,i(i({ref:t},p),{},{components:o})):n.createElement(h,i({ref:t},p))}));function u(e,t){var o=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=o.length,i=new Array(r);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<r;c++)i[c]=o[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}d.displayName="MDXCreateElement"},8772:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>f,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var n=o(7462),a=(o(7294),o(3905));const r={sidebar_position:2},i="5.2 Block format",l={unversionedId:"05block-validation/block_format",id:"05block-validation/block_format",title:"5.2 Block format",description:"Full Block",source:"@site/docs/05block-validation/block_format.md",sourceDirName:"05block-validation",slug:"/05block-validation/block_format",permalink:"/zh/docs/05block-validation/block_format",draft:!1,editUrl:"https://github.com/Chia-Network/chia-docs/blob/main/docs/05block-validation/block_format.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"5.1 Block Validation",permalink:"/zh/docs/05block-validation/block-validation"},next:{title:"5.3 Block rewards",permalink:"/zh/docs/05block-validation/block_rewards"}},s={},c=[{value:"Full Block",id:"full-block",level:2}],p={toc:c};function f(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,n.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"52-block-format"},"5.2 Block format"),(0,a.kt)("h2",{id:"full-block"},"Full Block"),(0,a.kt)("p",null,"The full block is the data structure that contains all information required for validating and adding block ",(0,a.kt)("inlineCode",{parentName:"p"},"N"),", assuming all blocks up to ",(0,a.kt)("inlineCode",{parentName:"p"},"N - 1")," have already been added. FullBlocks are sent over the network protocol, and also sometimes stored\non disk for the purpose of serving other nodes in the future."),(0,a.kt)("p",null,"The FullBlock has fields for both the trunk and the foliage of the blockchain. The ",(0,a.kt)("inlineCode",{parentName:"p"},"header_hash"),", which is used as the block identifier, is the hash of the ",(0,a.kt)("inlineCode",{parentName:"p"},"foliage")," field in ",(0,a.kt)("a",{parentName:"p",href:"/docs/08serialization/serialization"},"streamable")," format. This commits to all relevant data and to all previous blocks."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"finished_sub_sots"),": List","[EndOfSubSlotBundle]",": This contains all sub-slots that have been completed since the previous block in the chain (block ",(0,a.kt)("inlineCode",{parentName:"li"},"N-1"),")."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"reward_chain_block"),": RewardChainBlock: This is trunk data for the reward chain and challenge chain, including vdf outputs and proof of space."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"challenge_chain_sp_proof"),": Optional","[VDFProof]",": Proof of the VDF for the challenge chain signage point, not provided for the first signage point, since that is and end of sub slot."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"challenge_chain_ip_proof")," VDFProof: VDF proof from the previous cc infusion, up the infusion point."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"reward_chain_sp_proof"),": Optional","[VDFProof]",": Proof of the VDF for the reward chain signage point, not provided for the first signage point, since that is and end of sub slot."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"reward_chain_ip_proof")," VDFProof: VDF proof from the previous rc infusion, up to the infusion point."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"infused_challenge_chain_ip_proof"),": Optional","[VDFProof]",": The ICC proof, only present if deficit < 16"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"foliage"),": Foliage: Foliage data for the reward chain block, the hash of this is the ",(0,a.kt)("inlineCode",{parentName:"li"},"header_hash"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"foliage_transaction_block"),": Optional","[FoliageTransactionBlock]",": Transaction related metadata that is relevant for light clients (not actual transactions), only for tx blocks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"transactions_info"),": Optional","[TransactionsInfo]",": Transaction related metadata that is not relevant for light clients (not actual transactions), only for tx blocks."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"transactions_generator"),": Optional","[SerializedProgram]",": A clvm program that generates all transactions (spends)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"transactions_generator_ref_list"),": List","[uint32]",": A list of block heights of previous generators referenced by this block's generator.")),(0,a.kt)("p",null,"// TODO: include sub objects as well"))}f.isMDXComponent=!0}}]);